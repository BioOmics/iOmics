# !/bin/bash
# Author: Haoyu Chao
# Last modified: 2024-03-26
# Email: haoyuchao@zju.edu.cn
# Description: Bulk RNA-Seq quantification pipeline
# Dependences: sra-tools, fastp, STAR, sambamba, rsem, deeptools
# ==================================================
# software check ($1 is the software name, $2 is the software name need to install)
function CheckSoftware(){
    if command -v $1 >/dev/null 2>&1; then
        # echo -e "\033[1;34mCheck OK: \033[1;32m${2}\033[0m"
        sleep 0.05
    else
        echo -e "\033[1;31mError\033[0m: \033[1;32m${2}\033[0m can not be found in your PATH environment variable."
        echo -e "\033[1;34mHow to solve?\033[0m Please install \033[1;32m${2}\033[0m by conda (e.g. \033[1;32mconda install -c bioconda ${2} -y\033[0m) or other ways (pip or git clone) and add it to the PATH environment variable."
        echo -e "All required software: \033[1;32msra-tools, fastp, STAR, sambamba, rsem, deeptools\033[0m"
        exit 1
    fi
}
CheckSoftware "fasterq-dump" "sra-tools"
CheckSoftware "fastp" "fastp"
CheckSoftware "STAR" "STAR"
CheckSoftware "rsem-prepare-reference" "rsem"
CheckSoftware "sambamba" "sambamba"
CheckSoftware "deeptools" "deeptools"
# ==================================================

usage() {
cat << EOF
Description:
  Process RNA-Seq data, including quality control, 
  alignment, quantification and bigwig file generation. 

Usage:
  $(basename $0) -i input -g genome -a annotation [options]

Output:
  The output will be named as the input file name with "_$(basename $0)_result" suffix, including:
    1. fastp report
    2. alignment bam file
    3. quantification result
    
Options:
Required parameters:
  -i, --input        input file 1 (SRA, fastq, BAM or SAM)
  -I, --input2       input file 2 (fastq), only required in paired-end (PE) mode
  -g, --genome       reference genome (fasta)
  -a, --annotation   annotation file (gff3 or gtf)

Optional parameters:
  -q, --qualityBase  minimum quality value of average base quality (default: 20)
  -b, --binSize      generate bigwig file (default: no). Once use this option, 
                     you must set bin size by this option, such as "-b 10"
  -o, --output       output directory (default: same directory as input 
                     file with "_$(basename $0)_result" suffix)
  -t, --threads      number of threads (default: 8)
  -f, --force        force to overwrite the output directory
  -s, --skip         skip the step of have been done (default: no)
  -r, --remove       remove the intermediate files (default: no)
  -h, --help         show help information
  -v, --version      show version information

Example:
  1. For SRA data:
     $(basename $0) -i SRRID.sra -g genome.fa -a annotation.gff3
  2. For fastq SE data:
     $(basename $0) -i fileName.fq.gz -g genome.fa -a annotation.gtf
  3. For fastq PE data:
     $(basename $0) -i fileName_1.fq.gz -I fileName_2.fastq.gz -g genome.fa -a annotation.gff3
  4. For BAM data:
     $(basename $0) -i fileName.bam -g genome.fa -a annotation.gff3
  5. For SAM data:
     $(basename $0) -i fileName.sam -g genome.fa -a annotation.gff3

EOF
}

function checkParameter(){
    local parameterName=$1
    local value=$2
    if [[ -z $value || $value == -* ]]; then
        echo -e "\033[1;31mError\033[0m: No parameter provided for \"$1\""
        echo -e "\033[1;32mHow to solve?\033[0m Please provide the parameter required for \"$1\" option"
        exit 1
    else
        return 0
    fi
}

# get parameters from command line
while [[ $# -gt 0 ]]; do
  case $1 in
    -i|--input)  checkParameter $1 $2; if [[ $? -eq 0 ]]; then input=$2;shift 2; fi ;;
    -I|--input2) checkParameter $1 $2; if [[ $? -eq 0 ]]; then input2=$2;shift 2; fi ;;
    -o|--output) checkParameter $1 $2; if [[ $? -eq 0 ]]; then output=$2;shift 2; fi ;;
    -g|--genome) checkParameter $1 $2; if [[ $? -eq 0 ]]; then genome=$2;shift 2; fi ;;
    -a|--annotation) checkParameter $1 $2; if [[ $? -eq 0 ]]; then annotation=$2;shift 2; fi ;;
    -q|--qualityBase) checkParameter $1 $2; if [[ $? -eq 0 ]]; then qualityBase=$2;shift 2; fi ;;
    -b|--binSize) checkParameter $1 $2; if [[ $? -eq 0 ]]; then binSize=$2;shift 2; fi ;;
    -t|--threads) checkParameter $1 $2; if [[ $? -eq 0 ]]; then threads=$2;shift 2; fi ;;
    -f|--force) force=1; shift 1 ;;
    -s|--skip) skip=1; shift 1 ;;
    -r|--remove) remove=1; shift 1 ;;
    -h|--help) usage; exit 0 ;;
    -v|-V|--version) echo -e "Version: 1.0.0"; exit 0 ;;
    *) echo -e "\033[1;31mError\033[0m: $1 is not a valid option";echo -e "\033[1;32mHow to solve?\033[0m Please remove $1 option"; exit 1 ;;
  esac
done

# ==================================================
# ================parameters========================
# ==================================================

# --------------------"-h"--------------------------
# Print help information when no arguments passed or '-h' or '--help' option is used
if [[ $1 == "-h" || $1 == "--help" ]]; then
  usage
  echo $#
  exit 0
fi

# --------------------"-q"--------------------------
# if not use -q, then use default value
if [[ -z "$qualityBase" ]]; then
    qualityBase=20
elif [[ $qualityBase -lt 0 || $qualityBase -gt 40 ]]; then
    echo -e "\033[1;31mError\033[0m: the value of -q must be in the range of 0-40"
    echo -e "\033[1;32mHow to solve?\033[0m Please use \"-q\" option to specify the minimum quality, such as \"-q 30\""
    exit 1
fi

# --------------------"-b"--------------------------
# if not use -b, then use default value
if [[ -z "$binSize" ]]; then
    binSize=0
fi

# --------------------"-r"--------------------------
# if not use -r, then use 0
if [[ -z "$remove" ]]; then
    remove=0
fi

# --------------------"-t"--------------------------
# if not use -t, then use default threads; if threads is smaller than 1, exit
if [[ -z "$threads" ]]; then
    threads=8
elif [[ $threads -lt 2 ]]; then
    echo -e "\033[1;31mError\033[0m: the value of -t must be greater than 1"
    echo -e "\033[1;32mHow to solve?\033[0m Please use \"-t\" option to specify the number of threads, such as \"-t 8\""
    exit 1
fi

# --------------------"-s"--------------------------
# can not use -s and -f at the same time
if [[ $skip && $force ]]; then
    echo -e "\033[1;31mError\033[0m: -s and -f can not be used at the same time"
    echo -e "\033[1;32mHow to solve?\033[0m Please remove -s or -f option"
    exit 1
fi

# --------------------"-i"--------------------------
# check input file whether exist
if [[ -z "$input" ]]; then
    echo -e "\033[1;31mError\033[0m: -i is required"
    echo -e "\033[1;32mHow to solve?\033[0m Please specify the input file by \"-i\" option"
    exit 1
else 
    if [[ ! -f $input ]]; then
        echo -e "\033[1;31mError\033[0m: $input is not exist"
        echo -e "\033[1;32mHow to solve?\033[0m Please specify the path of input file by \"-i\" option"
        exit 1
    fi
fi

# --------------------"-I"--------------------------
# check input file 2 whether exist
if [ ! -z "$input2" ]; then
    if [ ! -f $input2 ]; then
        echo -e "\033[1;31mError\033[0m: $input2 is not exist"
        echo -e "\033[1;32mHow to solve?\033[0m Please specify the path of input file 2 by \"-I\" option"
        exit 1
    fi
fi

# --------------------"-g"--------------------------
if [ -z "$genome" ]; then
    echo -e "\033[1;31mError\033[0m: -g is required"
    exit 1
else
    # check genome file whether exist
    if [ ! -f $genome ]; then
        echo -e "\033[1;31mError\033[0m: $genome is not exist"
        echo -e "\033[1;32mHow to solve?\033[0m Please use \"-g\" option to specify the genome path"
        exit 1
    else
        # check the directory whether have permission to write
        if [[ ! -w $(dirname $genome) ]]; then
            echo -e "\033[1;31mError\033[0m: you don't have the permission to write in $(dirname $genome)"
            echo -e "\033[1;33mWhy error?\033[0m Because the genome index file will be generated in the same directory as the genome file"
            echo -e "\033[1;32mHow to solve?\033[0m Please copy genome file to your personal directory and use \"-g\" option to specify the new genome file"
            exit 1
        fi
    fi
fi

# --------------------"-a"--------------------------
if [ -z "$annotation" ]; then
    echo -e "\033[1;31mError\033[0m: -a is required"
    exit 1
else
    # check annotation file whether exist
    if [ ! -f $annotation ]; then
        echo -e "\033[1;31mError\033[0m: $annotation is not exist"
        echo -e "\033[1;32mHow to solve?\033[0m Please use \"-a\" option to specify the annotation file with correct path"
        exit 1
    else
        # check the directory whether have permission to write
        if [[ ! -w $(dirname $annotation) ]]; then
            echo -e "\033[1;31mError\033[0m: you don't have the permission to write in $(dirname $annotation)"
            echo -e "\033[1;33mWhy error?\033[0m Because other annotation files (such as bed/txt file) will be generated in the same directory as the annotation file"
            echo -e "\033[1;32mHow to solve?\033[0m Please copy annotation file to your personal directory and use \"-a\" option to specify the new annotation file"
            exit 1
        else
            # check the format of the annotation file
            if [[ $annotation != *.gff3 ]] && [[ $annotation != *.gtf ]]&& [[ $annotation != *.gff ]]; then
                echo -e "\033[1;31mError\033[0m: the format of $annotation is not supported"
                echo -e "\033[1;32mHow to solve?\033[0m Please use \"-a\" option to specify the annotation file with gff3/gtf/gff suffix"
                exit 1
            # check the content of the annotation file whether have nine columns
            else
                if [[ $(grep -v "#" $annotation | head -n 1 | awk -vFS="\t" '{print NF}') -ne 9 ]]; then
                    echo -e "\033[1;31mError\033[0m: the content of $annotation is not correct"
                    echo -e "\033[1;32mHow to solve?\033[0m Please check the content of the annotation file and make sure it have 9 columns"
                    exit 1
                fi
            fi
        fi
    fi
fi

# --------------------"-o"--------------------------
# if use -o, check whether the directory is exist and whether have same name file
if [[ ! -d $output && ! -f $output ]]; then
    mkdir $output
else
    if [[ $force ]]; then
        echo -e "\033[1;34mNote\033[0m: $output is exist, you used \"-f\" option to force overwrite the output directory or use \"-s\" option to skip the step of have been done"
        rm -rf $output
        mkdir $output
    elif [[ $skip ]]; then
        echo -e "\033[1;33mWarning\033[0m: $output is exist, you used \"-s\" option to skip the step of have been done"
    else
        echo -e "\033[1;31mError\033[0m: output directory \"$output\" is exist"
        echo -e "\033[1;32mHow to solve?\033[0m Please change the output directory name by \"-o\" option or use \"-f\" option to force overwrite the output directory or use \"-s\" option to skip the step of have been done"
        exit 1
    fi
fi

# if not use -o, then output to directory same as input
if [ -z "$output" ]; then
    output=${input}"_"$(basename $0)_"result"
    # check whether have the permission to write in the directory
    if [[ ! -w $(dirname $output) ]]; then
        echo -e "\033[1;31mError\033[0m: you don't have the permission to write in $(dirname $output)"
        echo -e "\033[1;33mWhy error?\033[0m Because the output file will be generated a $output in the same directory as the input file by default"
        echo -e "\033[1;32mHow to solve?\033[0m Please specify the output directory to your personal directory by \"-o\" option"
        exit 1
    else
        # if use -o, check whether the directory is exist and whether have same name file
        if [[ ! -d $output && ! -f $output ]]; then
            mkdir $output
        else
            if [[ $force ]]; then
                echo -e "\033[1;34mNote\033[0m: $output folder is exist, you used \"-f\" option to force overwrite the output directory or use \"-s\" option to skip the step of have been done"
                rm -rf $output
                mkdir $output
            elif [[ $skip ]]; then
                echo -e "\033[1;34mNote\033[0m: $output folder is exist, you used \"-s\" option to skip the step of have been done"
            else
                echo -e "\033[1;31mError\033[0m: output directory \"$output\" is exist"
                echo -e "\033[1;32mHow to solve?\033[0m Please change the output directory name by \"-o\" option or use \"-f\" option to force overwrite the output directory or use \"-s\" option to skip the step of have been done"
                exit 1
            fi
        fi
    fi
fi

# ==================================================
# ==================function========================
# ==================================================

# auto increase step number
step=1
function StepCounter() {
    echo -e "------------------------------------------"
    echo -e "\033[1;32mStep${step}:\033[0m $1"
    echo -e "------------------------------------------"
    ((step++))
}

# check whether the file is exist and whether have content
function BeforeCheck(){
    local input=$1
    if [[ -f $input && -s $input ]]; then
        echo -e "\033[1;34mNote:\033[0m $input is exist, skip this step. If you want to run this step, please remove the file (rm $input) and run the script again" >&2
        return 1
    else
        return 0
    fi
}

# check file whether exist and whether empty
function AfterCheck(){
    local input=$1
    if [[ ! -f $input || ! -s $input ]]; then
        echo -e "\033[1;31mError\033[0m: $input is not exist or empty"
        echo -e "\033[1;32mHow to solve?\033[0m Please check 1.above information; 2.your -i,-g,-a files; 3.your command"
        exit 1
    fi
}

# fasterq-dump
function FasterqDump(){
    local input=$(realpath $1)
    local output=$(realpath $2)
    BeforeCheck $output/*fastq
    if [[ $? -eq 0 ]]; then
        fasterq-dump -p --include-technical -S -e ${threads} -O ${output} ${input}
        AfterCheck ${output}/*fastq
    fi
}

# fastp
function Fastp(){
    local mode=$1
    local output=$2
    local input1=$3
    local output1=$4
    local input2=$5
    local output2=$6
    local fastpThreads=$((threads>=16?16:threads))
    BeforeCheck ${output1}
    if [[ $? -eq 0 ]]; then
        if [[ ${mode} == "SE" ]]; then
            fastp --thread ${fastpThreads} -q $qualityBase \
                -R "fastpc report for ${output}" \
                -i ${input1} -o ${output1} \
                -h ${output}.qc.html -j ${output}.qc.json
        else
            fastp --thread ${fastpThreads} -q $qualityBase \
                --detect_adapter_for_pe \
                -R "fastpc report for ${output}" \
                -i ${input1} -I ${input2} \
                -o ${output1} -O ${output2} \
                -h ${output}.qc.html -j ${output}.qc.json
        fi
        AfterCheck ${output1}
    fi
    total_reads_raw=$(grep -Pzo '"before_filtering":\s*{\s*[^{}]*\s*}' ${output}.qc.json | grep -Poa '"total_reads":\s*\K\d+')
    total_reads_clean=$(grep -Pzo '"after_filtering":\s*{\s*[^{}]*\s*}' ${output}.qc.json | grep -Poa '"total_reads":\s*\K\d+')
    bases_q30_rate=$(grep -Pzo '"after_filtering":\s*{\s*[^{}]*\s*}' ${output}.qc.json | grep -Poa '"q30_rate":\s*\K\d+(\.\d+)?' | awk '{printf "%.2f\n", $NF*100}')
    reads_mean_length=$(grep -Pzo '"after_filtering":\s*{\s*[^{}]*\s*}' ${output}.qc.json | grep -Poa '"read1_mean_length":\s*\K\d+')
    reads_gc_content=$(grep -Pzo '"after_filtering":\s*{\s*[^{}]*\s*}' ${output}.qc.json | grep -Poa '"gc_content":\s*\K\d+\.\d+' | awk '{printf "%.2f\n", $NF*100}')
    reads_duplication_rate=$(grep -Pzo '"duplication":\s*{\s*[^{}]*\s*}' ${output}.qc.json | grep -Poa '"rate":\s*\K\d+\.\d+' | awk '{printf "%.2f\n", $NF*100}')
}

# GTF check
function DeleteOverlapExon(){
    local annotation=$1
    sort -t $'\t' -k9,9 -k1,1V -k4,4n ${annotation} | \
    awk -vFS="\t" -vOFS="\t" '{
        if ($3 == "exon") {
            split($9, a, /";"/); split(a[1], b, / /);
            transcript_id = substr(b[2], 2);
            if (NR == 1) {
                prev_line = $0; prev_start = $4; prev_end = $5;
                prev_transcript_id = transcript_id;
            } else {
                if (transcript_id == prev_transcript_id) {
                    if ($4 <= prev_end && $5 >= prev_start) {
                        if (($5 - $4) >= (prev_end - prev_start)) {
                            prev_start = $4; prev_end = $5;
                        }
                    } else {
                        print prev_line; prev_line = $0;
                        prev_start = $4; prev_end = $5;
                    }
                } else {
                    print prev_line; prev_line = $0;
                    prev_start = $4; prev_end = $5;
                    prev_transcript_id = transcript_id;
                }
            }
        }
    } END {if (prev_line != "") {print prev_line}}' > ${annotation}.tmp
    mv ${annotation}.tmp ${annotation}
    sed -i '/^$/d' ${annotation}
}

# RSEM index
function RSEMIndex(){
    local annotation=$1
    local genome=$2
    local annotationIndex=$(dirname $(realpath ${annotation}))/RSEMIndex
    if [[ -f "${annotationIndex}/RSEMIndex.n2g.idx.fa" ]];then
        echo -e "\033[1;34mNote:\033[0m Index hes been built. Skip the step of build index. If you want to rebuild the index, please remove the index file (rm -rf ${annotationIndex}) and run the script again"
    else
        rm -rf ${annotationIndex}
        mkdir ${annotationIndex}
        echo -e "\033[1;34mNote:\033[0m Build RSEM index, it may take some time for the first time (next time will be skipped)"
        sed '/^$/d' ${annotation} > ${annotationIndex}/$(basename ${annotation}) # remove empty lines, or it will cause error in rsem-prepare-reference
        local annotation=${annotationIndex}/$(basename ${annotation})
        if [[ $annotation == *.gff3 ]] || [[ $annotation == *.gff ]]; then
            rsem-gff3-to-gtf ${annotation} ${annotationIndex}/$(basename ${annotation} .gff3).gtf
            DeleteOverlapExon ${annotationIndex}/$(basename ${annotation} .gff3).gtf
            rsem-prepare-reference --gtf ${annotationIndex}/$(basename ${annotation} .gff3).gtf ${genome} ${annotationIndex}/RSEMIndex
            cp ${annotationIndex}/$(basename ${annotation} .gff3).gtf ${annotationIndex}/RSEMIndex.gtf # it will be used in the STAR index step
        else
            DeleteOverlapExon ${annotation}
            rsem-prepare-reference --gtf ${annotation} ${genome} ${annotationIndex}/RSEMIndex
            cp ${annotation} ${annotationIndex}/RSEMIndex.gtf # it will be used in the STAR index step
        fi
        AfterCheck ${annotationIndex}/RSEMIndex.n2g.idx.fa
    fi
}

# STAR index
function STARIndex(){
    local genome=$1
    local annotation=$2
    local annotationIndex=$(dirname $(realpath ${annotation}))/RSEMIndex
    local alignmentIndex=$(dirname $(realpath ${genome}))/STARIndex
    local genomeSAindexNbases=$(awk '{i+=$2} END {if(log(i)/log(2)/2-1>=14){print 14}else{print int(log(i)/log(2)/2-1)}}' $annotationIndex/RSEMIndex.chrlist)
    if [[ -f "${alignmentIndex}/SA" ]];then
        echo -e "\033[1;34mNote:\033[0m Index hes been built. Skip the step of build index. If you want to rebuild the index, please remove the index file (rm -rf ${alignmentIndex}) and run the script again"
    else
        echo -e "\033[1;34mNote:\033[0m It may take a long time for the first time (next time will be skipped)"
        mkdir ${alignmentIndex}
        STAR --runThreadN ${threads} \
        --runMode genomeGenerate \
        --genomeDir ${alignmentIndex} \
        --genomeSAindexNbases ${genomeSAindexNbases} \
        --genomeFastaFiles ${genome} --sjdbGTFfile ${annotationIndex}/RSEMIndex.gtf --sjdbOverhang 100
        AfterCheck ${alignmentIndex}/SA
    fi
}

function calculateMaxThreadsforSTAR() {
    local threads=$1
    local maxThreads
    if [[ $threads -gt 16 ]]; then # choose 16, as then more than 16, STAR sort will add addtional files (16x3=48, is <50)
        tempThreads=$(ulimit -n | awk '{printf "%.0f", sqrt($1/3)-1}')
        if [[ $threads -gt $tempThreads ]]; then
            maxThreads=${tempThreads}
            echo -e "\033[1;33mWarning\033[0m: Your threads ($threads) is too large for STAR alignment ($maxThreads used). Because your system set \"ulimit -n\" to $(ulimit -n), which only allow use $maxThreads threads for STAR alignment. If you want to use more threads, please set ulimit -n to a larger value." >&2
        else
            maxThreads=${threads}
        fi
    else
        tempThreads=$(ulimit -n | awk '{printf "%.0f", $1/50-1}')
        if [[ $threads -gt $tempThreads ]]; then
            maxThreads=${tempThreads}
            echo -e "\033[1;33mWarning\033[0m: Your threads ($threads) is too large for STAR alignment ($maxThreads used). Because your system set \"ulimit -n\" to $(ulimit -n), which only allow use $maxThreads threads for STAR alignment. If you want to use more threads, please set ulimit -n to a larger value." >&2
        else
            maxThreads=${threads}
        fi
    fi
    echo "$maxThreads"
}

# STAR alignment
function STARAlignment(){
    local mode=$1
    local fq=$2
    local alignmentIndex=$3
    local fq1=$4
    local fq2=$5
    local maxThreads=$(calculateMaxThreadsforSTAR $threads)
    BeforeCheck ${fq}.Aligned.sortedByCoord.out.bam
    if [[ $? -eq 0 ]]; then
        if [[ ${mode} == "SE" ]]; then
            STAR --runThreadN ${maxThreads} \
            --genomeDir ${alignmentIndex} \
            --readFilesIn <(zcat ${fq1} || cat ${fq1} ) \
            --outFileNamePrefix ${fq}. \
            --outSAMtype BAM SortedByCoordinate \
            --outBAMsortingThreadN ${maxThreads} \
            --quantMode TranscriptomeSAM
        else
            STAR --runThreadN ${maxThreads} \
            --genomeDir ${alignmentIndex} \
            --readFilesIn <(zcat ${fq1} || cat ${fq1}) <(zcat ${fq2} || cat ${fq2}) \
            --outFileNamePrefix ${fq}. \
            --outSAMtype BAM SortedByCoordinate \
            --outBAMsortingThreadN ${maxThreads} \
            --quantMode TranscriptomeSAM
        fi
        AfterCheck ${fq}.Aligned.sortedByCoord.out.bam
    fi


    total_reads_unique_mapped=$(grep "Uniquely mapped reads number" ${fq}.Log.final.out | awk '{print $NF}')
    total_reads_multiple_mapped=$(grep "Number of reads mapped to multiple loci" ${fq}.Log.final.out | awk '{print $NF}')
    unique_mapped_rate=$(grep "Uniquely mapped reads %" ${fq}.Log.final.out | sed 's/%//g' | awk '{printf "%.2f\n", $NF}')

    BeforeCheck ${fq}.Aligned.sortedByCoord.out.bam.bai
    if [[ $? -eq 0 ]]; then
        sambamba index -t $threads ${fq}.Aligned.sortedByCoord.out.bam
        AfterCheck ${fq}.Aligned.sortedByCoord.out.bam.bai
    fi
}

# RSEM quantification
function RSEMQuantification(){
    local mode=$1
    local input=$2
    local annotationIndex=$3
    local output=$4
    BeforeCheck ${output}.genes.results
    if [[ $? -eq 0 ]]; then
        if [[ ${mode} == "SE" ]]; then
            rsem-calculate-expression --alignments -q -p ${threads} --no-bam-output -fragment-length-mean ${reads_mean_length} -fragment-length-sd 0 ${input} ${annotationIndex} ${output}
        else
            rsem-calculate-expression --alignments -q -p ${threads} --no-bam-output --estimate-rspd --paired-end ${input} ${annotationIndex} ${output}
        fi
        AfterCheck ${output}.genes.results
    fi
    total_expressed_genes=$(awk '{if($5>0){expressed++}} END {printf "%s (%.2f%%)\n", expressed, (expressed/NR)*100}' ${output}.genes.results)
    total_expressed_isoforms=$(awk '{if($5>0){expressed++}} END {printf "%s (%.2f%%)\n", expressed, (expressed/NR)*100}' ${output}.isoforms.results)
}

# Convert bam to bigwig
function BamToBw(){
    local input=$1
    local output=$2
    local binSize=$3
    BeforeCheck ${output}.bw
    if [[ $? -eq 0 ]]; then
        sambamba index -t $threads ${input}
        bamCoverage --bam ${input} -o ${output}.bw --binSize ${binSize} -p ${threads} --normalizeUsing CPM
        AfterCheck ${output}.bw
    fi
}

# remove the intermediate files
function RemoveIntermediateFiles(){
    local input=$1
    rm -rf ${input}*STARtmp ${input}*.fastq ${input}*.stat
    echo -e "\033[1;34mNote:\033[0m Intermediate files have been removed"
}

# Statics
function Statics(){
    echo -e "Clean Bases Q30 rate: ${bases_q30_rate}%"
    echo -e "Clean Reads mean length: ${reads_mean_length}"
    echo -e "Clean Reads GC content: ${reads_gc_content}%"
    echo -e "Clean Reads duplication rate: ${reads_duplication_rate}%"
    echo -e "Total raw reads: ${total_reads_raw}"
    echo -e "Total clean reads: ${total_reads_clean}"
    echo -e "Total unique mapped reads: ${total_reads_unique_mapped}"
    echo -e "Total multiple mapped reads: ${total_reads_multiple_mapped}"
    echo -e "Total expressed genes: ${total_expressed_genes}"
    echo -e "Total expressed isoforms: ${total_expressed_isoforms}"
    if [[ $(echo ${unique_mapped_rate} | awk '{print int($NF)}') -ge 90 ]]; then
        echo -e "Unique mapping rate: \033[1;32m${unique_mapped_rate}%\033[0m"
    elif [[ $(echo ${unique_mapped_rate} | awk '{print int($NF)}') -ge 70 ]]; then
        echo -e "Unique mapping rate: \033[1;33m${unique_mapped_rate}%\033[0m"
    else
        echo -e "Unique mapping rate: \033[1;31m${unique_mapped_rate}%\033[0m"
    fi
}

# ==================================================
# ==================process=========================
# ==================================================
# use sra mode only when the suffix of the file name is sra or SRA, or without suffix
tempName=$(basename $input)

if [[ -f ${output}/${tempName%%.*}.$(basename $0).report.txt ]]; then
    echo -e "\033[1;34mNote:\033[0m ${output}/${tempName%%.*}.$(basename $0).report.txt is exist, means all steps have been done. If you want to analysis $input again, please remove the file (rm ${output}/${tempName%%.*}.$(basename $0).report.txt) and run the script again" >&2
    exit 0
fi

# if input only one file, then use fellow mode
if [ -z "$input2" ]; then
    if [[ $input == *.sra ]] || [[ $input == *.SRA ]] || [[ ${tempName} == ${tempName%%.*} ]] ; then # due to "%%.*" will delete all content before the last ".", so we need to get the file name first, or the pathway like "../test" will be treated as "."
        if [[ ${tempName} == ${tempName%%.*} ]]; then
            echo -e "\033[1;33mWarning\033[0m: your file ($input) without suffix (such as ".sra"). SRA mode will be used by default."
        fi
        # ====================================================================================================
        # ======================================== Start of SRA mode =========================================
        # ====================================================================================================

        # -------------------------- Split SRA file --------------------------
        StepCounter "Split SRA to fastq"
        FasterqDump ${input} ${output}

        if [[ -f "${output}/${tempName%%.*}_2.fastq" && ! -f "${output}/${tempName%%.*}_3.fastq" ]];then # check whether the SRA file is paired-end or single-end
        # ========================== paired-end data ===============================
            # -------------------------- quality control for PE data -------------
            StepCounter "Quality control for PE data"
            Fastp "PE" ${output}/${tempName%%.*} \
                  ${output}/${tempName%%.*}_1.fastq ${output}/${tempName%%.*}_1.clean.fastq \
                  ${output}/${tempName%%.*}_2.fastq ${output}/${tempName%%.*}_2.clean.fastq 
            
            # -------------------------- build RSEM index ------------------------
            StepCounter "Build RSEM index"
            RSEMIndex ${annotation} ${genome}

            # -------------------------- build alignment index -------------------
            StepCounter "Build alignment index"
            STARIndex ${genome} ${annotation}

            # -------------------------- alignment -------------------------------
            StepCounter "Alignment"
            STARAlignment "PE" ${output}/${tempName%%.*} $(dirname $(realpath ${genome}))/STARIndex ${output}/${tempName%%.*}_1.clean.fastq ${output}/${tempName%%.*}_2.clean.fastq
            
            # -------------------------- quantification -------------
            StepCounter "Quantification"
            RSEMQuantification "PE" ${output}/${tempName%%.*}.Aligned.toTranscriptome.out.bam $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/${tempName%%.*}

            # ------------------------- convert bam to bigwig -------------
            if [[ ${binSize} -gt 0 ]]; then
                StepCounter "Convert bam to bigwig"
                BamToBw ${output}/${tempName%%.*}.Aligned.sortedByCoord.out.bam ${output}/${tempName%%.*} ${binSize}
            fi

            # ------------------------- remove the intermediate files -----------
            if [[ ${remove} == "1" ]];then
                StepCounter "Remove the intermediate files"
                RemoveIntermediateFiles ${output}/${tempName%%.*}
            fi
        elif [[ -f "${output}/${tempName%%.*}.fastq" || ( -f "${output}/${tempName%%.*}_1.fastq" && ! -f "${output}/${tempName%%.*}_2.fastq" ) ]];then
        # ========================== single-end data ===============================
            # -------------------------- quality control for SE data -------------
            StepCounter "Quality control for SE data"
            Fastp "SE" ${output}/${tempName%%.*} \
                  ${output}/${tempName%%.*}.fastq ${output}/${tempName%%.*}.clean.fastq

            # -------------------------- build RSEM index ------------------------
            StepCounter "Build RSEM index"
            RSEMIndex ${annotation} ${genome}

            # -------------------------- build alignment index -------------------
            StepCounter "Build alignment index"
            STARIndex ${genome} ${annotation}

            # -------------------------- alignment -------------------------------
            StepCounter "Alignment"
            STARAlignment "SE" ${output}/${tempName%%.*} $(dirname $(realpath ${genome}))/STARIndex ${output}/${tempName%%.*}.clean.fastq

            # -------------------------- quantification -------------
            StepCounter "Quantification"
            RSEMQuantification "SE" ${output}/${tempName%%.*}.Aligned.toTranscriptome.out.bam $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/${tempName%%.*}

            # ------------------------- convert bam to bigwig -------------
            if [[ ${binSize} -gt 0 ]]; then
                StepCounter "Convert bam to bigwig"
                BamToBw ${output}/${tempName%%.*}.Aligned.sortedByCoord.out.bam ${output}/${tempName%%.*} ${binSize}
            fi

            # ------------------------- remove the intermediate files -----------
            if [[ ${remove} == "1" ]];then
                StepCounter "Remove the intermediate files"
                RemoveIntermediateFiles ${output}/${tempName%%.*}
            fi
        else
            echo -e "\033[1;31mError\033[0m: your file ($input) is not paired-end or single-end, maybe it is single cell data"
            echo -e "\033[1;32mHow to solve?\033[0m Please check your file ($input) and make sure it is suitable for this script"
            exit 1
        fi
        # ====================================================================================================
        # ========================================= End of SRA mode ==========================================
        # ====================================================================================================
        StepCounter "Finnal statics"
        Statics
        Statics | sed "s/\x1B\[[0-9;]*[JKmsu]//g" > ${output}/${tempName%%.*}.$(basename $0).report.txt
        exit 0
    fi
    # if the suffix of the file name is fastq or fastq.gz or fq.gz or fq, then use fastq mode
    if [[ $input == *.fastq ]] || [[ $input == *.fastq.gz ]] || [[ $input == *.fq.gz ]] || [[ $input == *.fq ]]; then

        # ====================================================================================================
        # ======================================== Start of fastq SE mode ====================================
        # ====================================================================================================
        # -------------------------- quality control for SE data -------------
        StepCounter "Quality control for SE data"
        Fastp "SE" ${output}/${tempName%%.*} ${input} ${output}/${tempName%%.*}.clean.fastq

        # -------------------------- build RSEM index ------------------------
        StepCounter "Build RSEM index"
        RSEMIndex ${annotation} ${genome}

        # -------------------------- build alignment index -------------------
        StepCounter "Build alignment index"
        STARIndex ${genome} ${annotation}

        # -------------------------- alignment -------------------------------
        StepCounter "Alignment"
        STARAlignment "SE" ${output}/${tempName%%.*} $(dirname $(realpath ${genome}))/STARIndex ${output}/${tempName%%.*}.clean.fastq

        # -------------------------- quantification -------------
        StepCounter "Quantification"
        RSEMQuantification "SE" ${output}/${tempName%%.*}.Aligned.toTranscriptome.out.bam $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/${tempName%%.*}

        # ------------------------- convert bam to bigwig -------------
        if [[ ${binSize} -gt 0 ]]; then
            StepCounter "Convert bam to bigwig"
            BamToBw ${output}/${tempName%%.*}.Aligned.sortedByCoord.out.bam ${output}/${tempName%%.*} ${binSize}
        fi

        # ------------------------- remove the intermediate files -----------
        if [[ ${remove} == "1" ]];then
            StepCounter "Remove the intermediate files"
            RemoveIntermediateFiles ${output}/${tempName%%.*}
        fi
        # ====================================================================================================
        # ======================================== End of fastq SE mode ======================================
        # ====================================================================================================
        StepCounter "Finnal statics"
        Statics
        Statics | sed "s/\x1B\[[0-9;]*[JKmsu]//g" > ${output}/${tempName%%.*}.$(basename $0).report.txt
        exit 0
    fi
    if [[ $input == *.bam ]]; then
        # ====================================================================================================
        # ======================================== Start of bam mode =========================================
        # ====================================================================================================
        # -------------------------- build RSEM index ------------------------
        StepCounter "Build RSEM index"
        RSEMIndex ${annotation} ${genome}

        # -------------------------- build alignment index -------------------
        StepCounter "Build alignment index"
        STARIndex ${genome} ${annotation}

        # -------------------------- quantification -------------
        StepCounter "Quantification"
        odd_count=$(sambamba view ${input} | head -10000 | cut -f 2 | sort | uniq | awk '$1 % 2 == 0'|wc -l)
        if [[ ${odd_count} -gt 0 ]]; then
            RSEMQuantification "SE" ${input} $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/${tempName%%.*}
        else
            RSEMQuantification "PE" ${input} $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/${tempName%%.*}
        fi
    
        # ------------------------- convert bam to bigwig -------------
        # if [[ ${binSize} -gt 0 ]]; then
        #     StepCounter "Convert bam to bigwig"
        #     BamToBw ${input} ${output}/${tempName%%.*} ${binSize}
        # fi

        # ------------------------- remove the intermediate files -----------
        if [[ ${remove} == "1" ]];then
            StepCounter "Remove the intermediate files"
            RemoveIntermediateFiles ${output}/${tempName%%.*}
        fi

        # ====================================================================================================
        # ======================================== End of bam mode ===========================================
        # ====================================================================================================
        StepCounter "Finnal statics"
        Statics
        Statics | sed "s/\x1B\[[0-9;]*[JKmsu]//g" > ${output}/${tempName%%.*}.$(basename $0).report.txt
        exit 0
    fi
    if [[ $input == *.sam ]]; then
        # ====================================================================================================
        # ======================================== Start of sam mode =========================================
        # ====================================================================================================
        # -------------------------- build RSEM index ------------------------
        StepCounter "Build RSEM index"
        RSEMIndex ${annotation} ${genome}

        # -------------------------- build alignment index -------------------
        StepCounter "Build alignment index"
        STARIndex ${genome} ${annotation}

        # -------------------------- convert sam to bam -----------------------
        StepCounter "Convert sam to bam"
        sambamba view -h -f bam -t ${threads} -S ${input} -o ${output}/$(basename ${input} .sam).bam

        # -------------------------- quantification -------------
        StepCounter "Quantification"
        odd_count=$(sambamba view ${output}/$(basename ${input} .sam).bam | head -10000 | cut -f 2 | sort | uniq | awk '$1 % 2 == 0'|wc -l)
        if [[ ${odd_count} -gt 0 ]]; then
            RSEMQuantification "SE" ${output}/$(basename ${input} .sam).bam $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/$(basename ${input} .sam)
        else
            RSEMQuantification "PE" ${output}/$(basename ${input} .sam).bam $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/$(basename ${input} .sam)
        fi

        # ------------------------- convert bam to bigwig -------------
        # if [[ ${binSize} -gt 0 ]]; then
        #     StepCounter "Convert bam to bigwig"
        #     BamToBw ${output}/$(basename ${input} .sam).bam ${output}/$(basename ${input%%.*}) ${binSize}
        # fi

        # ------------------------- remove the intermediate files -----------
        if [[ ${remove} == "1" ]];then
            StepCounter "Remove the intermediate files"
            RemoveIntermediateFiles ${output}/$(basename ${input%%.*})
        fi

        # ====================================================================================================
        # ======================================== End of sam mode ===========================================
        # ====================================================================================================
        StepCounter "Finnal statics"
        Statics
        Statics | sed "s/\x1B\[[0-9;]*[JKmsu]//g" > ${output}/${tempName%%.*}.$(basename $0).report.txt
        exit 0
    fi
    # if the suffix of the file name is not sra or fastq or fastq.gz or fq.gz or fq or bam or sam, then print \033[1;31mError\033[0m information
    if [[ ${tempName} != ${tempName%%.*} ]] && [[ $input != *.sra ]] && [[ $input != *.SRA ]] && [[ $input != *.fastq ]] && [[ $input != *.fastq.gz ]] && [[ $input != *.fq.gz ]] && [[ $input != *.fq ]] && [[ $input != *.bam ]] && [[ $input != *.sam ]]; then
        echo -e "\033[1;31mError\033[0m: we can't recognize your input file."
        echo -e "\033[1;32mHow to solve?\033[0m Please check your input file type."
        echo -e "\033[1;34mNote:\033[0m only SRA(.sra), Fastq(.fq/.fq.gz), BAM(.bam) or SAM(.sam) are supported as input."
        exit 1
    fi
# if input two files, then use paired end mode and if the suffix must be fastq or fastq.gz or fq.gz or fq
else
    if [[ $input == *.fastq && $input2 == *.fastq ]] || [[ $input == *.fastq.gz && $input2 == *.fastq.gz ]] || [[ $input == *.fq.gz && $input2 == *.fq.gz ]] || [[ $input == *.fq && $input2 == *.fq ]]; then
        if [ $input == $input2 ]; then
            echo -e "\033[1;31mError\033[0m: -i and -I input file must be different."
            exit 1
        else
            # ====================================================================================================
            # ======================================== Start of PE mode ==========================================
            # ====================================================================================================
            # -------------------------- quality control for PE data -------------
            StepCounter "Quality control for PE data"
            Fastp "PE" ${output}/${tempName%%.*} ${input} ${output}/${tempName%%.*}_1.clean.fastq ${input2} ${output}/${tempName%%.*}_2.clean.fastq

            # -------------------------- build RSEM index ------------------------
            StepCounter "Build RSEM index"
            RSEMIndex ${annotation} ${genome}

            # -------------------------- build alignment index -------------------
            StepCounter "Build alignment index"
            STARIndex ${genome} ${annotation}

            # -------------------------- alignment -------------------------------
            StepCounter "Alignment"
            STARAlignment "PE" ${output}/${tempName%%.*} $(dirname $(realpath ${genome}))/STARIndex ${output}/${tempName%%.*}_1.clean.fastq ${output}/${tempName%%.*}_2.clean.fastq

            # -------------------------- quantification -------------
            StepCounter "Quantification"
            RSEMQuantification "PE" ${output}/${tempName%%.*}.Aligned.toTranscriptome.out.bam $(dirname $(realpath ${annotation}))/RSEMIndex/RSEMIndex ${output}/${tempName%%.*}

            # ------------------------- convert bam to bigwig -------------
            if [[ ${binSize} -gt 0 ]]; then
                StepCounter "Convert bam to bigwig"
                BamToBw ${output}/${tempName%%.*}.Aligned.sortedByCoord.out.bam ${output}/${tempName%%.*} ${binSize}
            fi

            # ------------------------- remove the intermediate files -----------
            if [[ ${remove} == "1" ]];then
                StepCounter "Remove the intermediate files"
                RemoveIntermediateFiles ${output}/${tempName%%.*}
            fi
            # ====================================================================================================
            # ======================================== End of PE mode ============================================
            # ====================================================================================================
            StepCounter "Finnal statics"
            Statics
            Statics | sed "s/\x1B\[[0-9;]*[JKmsu]//g" > ${output}/${tempName%%.*}.$(basename $0).report.txt
            exit 0
        fi 
    else
        echo -e "\033[1;31mError\033[0m: -i and -I must have same file type (.fastq/.fastq.gz/fq.gz/fq)"
        exit 1
    fi
fi
